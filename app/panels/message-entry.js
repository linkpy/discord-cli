// Generated by CoffeeScript 1.9.3
var Blessed, Debug, EventEmitter, MessageEntry, MessageParser, wordwrap, wrapsplit, wrapsplitml,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Blessed = require("blessed");

EventEmitter = require("events");

MessageParser = require("../utils/message-parser.js");

Debug = require("../debug.js");

wrapsplit = function(str, width) {
  var i, j, k, len, lines, ref, split, sum, word;
  sum = function(arr) {
    var j, len, out, word;
    out = 0;
    if (arr.length !== 0) {
      for (j = 0, len = arr.length; j < len; j++) {
        word = arr[j];
        out += word.length;
      }
      return out + arr.length - 1;
    }
    return 0;
  };
  lines = [[]];
  split = str.split(' ');
  for (j = 0, len = split.length; j < len; j++) {
    word = split[j];
    if (sum(lines[lines.length - 1]) + word.length > width) {
      lines.push([]);
    }
    lines[lines.length - 1].push(word);
  }
  for (i = k = 0, ref = lines.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
    lines[i] = lines[i].join(" ");
  }
  return lines;
};

wrapsplitml = function(str, width) {
  var j, len, out, part, parts;
  parts = str.split("\n");
  if (parts.length === 0) {
    return wrapsplit(str, width);
  }
  out = [];
  for (j = 0, len = parts.length; j < len; j++) {
    part = parts[j];
    out = out.concat(wrapsplit(part, width));
  }
  return out;
};

wordwrap = function(str, width, brk) {
  brk = brk || '\n';
  return wrapsplit(str, width).join(brk);
};

MessageEntry = (function(superClass) {
  extend(MessageEntry, superClass);

  function MessageEntry(app, mainscreen, pannel, m) {
    MessageEntry.__super__.constructor.call(this);
    this.app = app;
    this.mainscreen = mainscreen;
    this.storage = mainscreen.storage;
    this.pannel = pannel;
    this.channel = m.channel;
    this.guild = this.channel.guild;
    this.message = m;
    this.has_text = m.content.length !== 0;
    this.has_attachements = m.attachments.array().length !== 0;
    this.user = m.author;
    this.guild_member = null;
    this.guild_role = null;
    this.index = -1;
    this.box = null;
    this.author = null;
    this.content = null;
    this.attachments = null;
    this.updateRole();
  }

  MessageEntry.prototype.setupUI = function(top) {
    this.box = Blessed.box({
      parent: this.pannel.box,
      clickable: true,
      keyable: false,
      top: top,
      left: 0,
      width: "100%",
      height: 1,
      style: {
        bg: "black"
      }
    });
    this.author = Blessed.text({
      parent: this.box,
      clickable: true,
      tags: true,
      top: 0,
      left: 0,
      style: {
        fg: "white",
        bg: "black"
      }
    });
    this.content = Blessed.text({
      parent: this.box,
      clickable: true,
      tags: true,
      top: 0,
      left: 20,
      style: {
        fg: "grey",
        bg: "black"
      }
    });
    this.attachments = Blessed.text({
      parent: this.box,
      clickable: true,
      top: 0,
      left: 20,
      style: {
        fg: "cyan",
        bg: "black"
      }
    });
    return this.fill();
  };

  MessageEntry.prototype.destroyUI = function() {
    this.attachments.destroy();
    this.content.destroy();
    this.author.destroy();
    return this.box.destroy();
  };

  MessageEntry.prototype.setupEvents = function() {
    var self;
    self = this;
    this.box.on("click", function() {
      return self.emit("selected", self);
    });
    this.author.on("click", function() {
      self.emit("selected", self);
      return self.emit("author-clicked", self);
    });
    this.content.on("click", function() {
      return self.emit("selected", self);
    });
    return this.attachments.on("click", function(mouse) {
      var attachment, idx, list;
      self.emit("selected", self);
      list = self.message.attachments.array();
      idx = mouse.y - self.attachments.atop;
      attachment = list[idx];
      if (attachment != null) {
        return self.emit("attachment-clicked", self);
      } else {
        throw new Error();
      }
    });
  };

  MessageEntry.prototype.updateRole = function() {
    if ((this.guild != null) && this.guild.available) {
      this.guild_user = this.message.member;
      if (this.guild_user == null) {
        return;
      }
      return this.guild_role = this.guild_user.highestRole;
    }
  };

  MessageEntry.prototype.fill = function() {
    var a, attachments, author, j, k, l, len, len1, len2, lines, mw, n, ref, self, size;
    self = this;
    author = this.user.username.slice(0, 18);
    attachments = [];
    lines = [];
    if (this.message.type === "DEFAULT" && this.has_text) {
      mw = this.box.width - 22;
      lines = wrapsplitml(MessageParser.Parse(this.app, this.message), mw);
    } else if (this.message.type === "PINS_ADD") {
      this.has_text = true;
      lines = ["{yellow-fg}has pinned a new message to this channel.{/}"];
    }
    ref = this.message.attachments.array();
    for (j = 0, len = ref.length; j < len; j++) {
      a = ref[j];
      size = Math.round(a.filesize / 1024 * 1000) / 1000;
      attachments.push("[" + a.filename + " - " + size + "Ko]");
    }
    lines = lines.filter(function(l) {
      return l.length !== 0;
    });
    if (this.has_text) {
      this.box.position.height = lines.length;
      this.content.show();
    } else {
      this.content.hide();
    }
    if (this.has_attachements) {
      if (!this.has_text) {
        this.box.position.height = attachments.length;
      } else {
        this.attachments.position.top = lines.length;
        this.box.position.height += attachments.length;
      }
      this.attachments.show();
    } else {
      this.attachments.hide();
    }
    if (this.guild_role) {
      this.author.setContent("{" + this.guild_role.hexColor + "-fg}" + author + "{/}");
    } else {
      this.author.setContent(author);
    }
    for (k = 0, len1 = lines.length; k < len1; k++) {
      l = lines[k];
      this.content.pushLine(l);
    }
    for (n = 0, len2 = attachments.length; n < len2; n++) {
      a = attachments[n];
      this.attachments.pushLine(a);
    }
    return this.box.position.height += 1;
  };

  MessageEntry.prototype.applyOffset = function(offs) {
    return this.box.position.top -= offs;
  };

  MessageEntry.prototype.hide = function() {
    return this.box.hide();
  };

  MessageEntry.prototype.select = function() {
    this.box.style.bg = "white";
    this.author.style.bg = "white";
    this.content.style.bg = "white";
    return this.attachments.style.bg = "white";
  };

  MessageEntry.prototype.unselect = function() {
    this.box.style.bg = "black";
    this.author.style.bg = "black";
    this.content.style.bg = "black";
    return this.attachments.style.bg = "black";
  };

  MessageEntry.prototype.getTop = function() {
    return this.box.position.top;
  };

  MessageEntry.prototype.getHeight = function() {
    return this.box.position.height;
  };

  return MessageEntry;

})(EventEmitter);

exports.MessageEntry = MessageEntry;
