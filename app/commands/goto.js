// Generated by CoffeeScript 1.9.3
var Command, Debug, GotoCommand,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Command = require("../command.js").Command;

Debug = require('../debug.js');

GotoCommand = (function(superClass) {
  extend(GotoCommand, superClass);

  function GotoCommand(app, mainscreen) {
    GotoCommand.__super__.constructor.call(this, app, mainscreen, "goto");
    this.storage = mainscreen.storage;
    this.lastGuild = "";
  }

  GotoCommand.prototype.haveSuggestions = function(argidx) {
    return true;
  };

  GotoCommand.prototype.suggestions = function(arg, argidx, args) {
    var fc, line;
    line = args.join(' ').trim();
    fc = line[0];
    if (fc !== "#" && fc !== "@") {
      return this.suggestionsGuildChan(args);
    }
    if (fc === "#") {
      return this.suggestionsChan(args);
    }
    if (fc === "@") {
      return this.suggestionsFriends(args);
    }
    return [];
  };

  GotoCommand.prototype.argumentName = function(argidx) {
    return "Target";
  };

  GotoCommand.prototype.execute = function(args) {
    var fc, line;
    line = args.join(' ').trim();
    fc = line[0];
    if (fc !== "#" && fc !== "@") {
      return this.executeGuildChan(args);
    } else if (fc === "#") {
      return this.executeChan(args);
    } else if (fc === "@") {
      return this.executeFriends(args);
    } else {
      throw new Error("Invalid argument(s)");
    }
  };

  GotoCommand.prototype.suggestionsGuildChan = function(args) {
    var chan, channelname, g, guild, guildname, i, j, k, len, len1, len2, line, names, ref, ref1, ref2, sepi;
    line = args.join(' ');
    sepi = line.indexOf("#");
    guildname = "";
    channelname = "";
    if (sepi === -1) {
      guildname = line.trim();
      names = [];
      ref = this.storage.guilds;
      for (i = 0, len = ref.length; i < len; i++) {
        guild = ref[i];
        if (guild.available) {
          if (guild.name.startsWith(line)) {
            names.push(guild.name);
          }
        }
      }
      return names;
    }
    guildname = line.slice(0, sepi).trim();
    channelname = line.slice(sepi + 1).trim();
    guild = null;
    ref1 = this.storage.guilds;
    for (j = 0, len1 = ref1.length; j < len1; j++) {
      g = ref1[j];
      if (g.available && g.name === guildname) {
        guild = g;
        break;
      }
    }
    if (!guild) {
      return ["Unknown Guild"];
    }
    names = [];
    ref2 = guild.channels.array();
    for (k = 0, len2 = ref2.length; k < len2; k++) {
      chan = ref2[k];
      if (this.app.filterChannel(chan)) {
        if (chan.name.startsWith(channelname)) {
          names.push("#" + chan.name);
        }
      }
    }
    return names;
  };

  GotoCommand.prototype.suggestionsChan = function(args) {
    var chan, guild, i, len, line, names, ref;
    line = args[0].slice(1);
    guild = this.storage.current_guild;
    if (guild === null) {
      return ["Not in a server"];
    }
    names = [];
    ref = guild.channels.array();
    for (i = 0, len = ref.length; i < len; i++) {
      chan = ref[i];
      if (this.app.filterChannel(chan)) {
        if (chan.name.startsWith(line)) {
          names.push("#" + chan.name);
        }
      }
    }
    return names;
  };

  GotoCommand.prototype.suggestionsFriends = function(args) {
    var friend, friends, i, len, line, names;
    line = args.join(' ').trim().slice(1);
    friends = this.storage.client.user.friends.array();
    names = [];
    for (i = 0, len = friends.length; i < len; i++) {
      friend = friends[i];
      if (friend.username.startsWith(line)) {
        names.push("@" + friend.username);
      }
    }
    return names;
  };

  GotoCommand.prototype.executeGuildChan = function(args) {
    var c, chan, cname, g, gname, guild, i, j, k, len, len1, len2, line, ref, ref1, ref2, sepi;
    line = args.join(' ');
    sepi = line.indexOf("#");
    if (sepi === -1) {
      guild = null;
      ref = this.storage.guilds;
      for (i = 0, len = ref.length; i < len; i++) {
        g = ref[i];
        if (g.available && g.name === line.trim()) {
          guild = g;
          break;
        }
      }
      if (guild == null) {
        throw new Error("Server '" + (line.trim()) + "' doesn't exists.");
      }
      return this.storage.selectGuild(guild);
    } else {
      gname = line.slice(0, sepi).trim();
      cname = line.slice(sepi + 1).trim();
      guild = null;
      chan = null;
      ref1 = this.storage.guilds;
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        g = ref1[j];
        if (g.available && g.name === gname) {
          guild = g;
          break;
        }
      }
      if (guild == null) {
        throw new Error("Server '" + gname + "' doesn't exists.");
      }
      if (!guild.available) {
        throw new Error("Can't go to channel '" + cname + "' : server unavailable.");
      }
      ref2 = guild.channels.array();
      for (k = 0, len2 = ref2.length; k < len2; k++) {
        c = ref2[k];
        if (c.name === cname) {
          chan = c;
          break;
        }
      }
      if (!chan) {
        throw new Error("Channel '" + cname + "' doesn't exists in the given server.");
      }
      this.storage.selectGuild(guild, false);
      return this.storage.selectChannel(chan);
    }
  };

  GotoCommand.prototype.executeChan = function(args) {
    var c, chan, guild, i, len, line, ref;
    line = args[0].slice(1);
    guild = this.storage.current_guild;
    chan = null;
    if (guild == null) {
      throw new Error("Not in a server.");
    }
    if (!guild.available) {
      throw new Error("Can't go to channel '" + line + "' : server unavailable.");
    }
    ref = guild.channels.array();
    for (i = 0, len = ref.length; i < len; i++) {
      c = ref[i];
      if (c.name === line) {
        chan = c;
        break;
      }
    }
    if (chan == null) {
      throw new Error("Channel '" + line + "' doesn't exists in the given server.");
    }
    return this.storage.selectChannel(chan);
  };

  GotoCommand.prototype.executeFriends = function(args) {
    var chan, friend, friends, i, len, line;
    line = args.join(' ').trim().slice(1);
    friends = this.storage.client.user.friends.array();
    for (i = 0, len = friends.length; i < len; i++) {
      friend = friends[i];
      if (friend == null) {
        throw new Error("wut");
      }
      if (friend.username === line) {
        chan = friend.dmChannel;
        if (chan == null) {
          throw new Error("Can't go to '@" + line + "' : no direct-message channel.");
        }
        this.storage.selectGuild(null, false);
        this.storage.selectChannel(chan);
        return;
      }
    }
    throw new error("Friend @'" + line + "' doesn't exists.");
  };

  GotoCommand.prototype.getHelpText = function() {
    return ["{magenta-fg}/goto <server name> [#channel name]{/}", "{magenta-fg}/goto <#channel name>{/}", "{magenta-fg}/goto <@friend username>{/}", "", "Go to the given server and channel (if given).", "", "    {blue-fg}{bold}/goto <server name>{/} : Go to the general channel of the given server.", "    {blue-fg}{bold}/goto <server name> #<channel name>{/} : Go to the given channel in the given server.", "    {blue-fg}{bold}/goto #<channel name>{/} : Go to the given channel in the current server.", "    {blue-fg}{bold}/goto @<friend name>{/} : Go to the friend direct-message channel."];
  };

  return GotoCommand;

})(Command);

exports.Command = GotoCommand;
